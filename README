How to use: To use this shell, 1st utilize “make clean all” in the project directory terminal. Then either use “./33nopromt” or “./33sh” to run the shell. From there you can utilize shell commands such as “/bin/echo hi” and other commands to run the shell. Furthermore, you can utilize redirect symbols such as > to transfer outputs to files or < to utilize a file as an input. Furthermore, when you start a job, such as by typing in “/bin/sleep 20” you can stop it using CTRL Z and then restart either in the background using “bg %(and then the job ID)” so for example if the job ID was 3, you could type “bg %3” and the job would start as a background process. If you want to start this process in the foreground, you simply have to type “fg %(job ID)” and if you want to move a background process to the foreground, additionally simply type “fg %(job ID). To terminate a process in the foreground simply type CTRL C. To see your current jobs list, type jobs into the terminal. 

Description of Program:
Our program contains a main method that creates a myriad of arrays such as the buffer array, tokens array, argv array, and no_redirects array. We then included an infinite while loop to ensure the program constantly asks for user input. We additionally first populate each array to null using memset to ensure no "junk" values inhibit our comparisons and functions later on. We then call parse to create a parsed argsv and tokens array. From there, we call parse_redirects which then populates the no_redirects array which contains the same objects as argv but without the redirect symbol and the file that directly follows them. We then call check_sys_cmnds which checks to see if the user inputted cd, ln, rm, or exit. There we utilized the correct system calls to give these each functionality and error checked them as well. We next called get_filepath which will return the correct filepath by assigning tokens to the correct part of the user input if a redirect symbol is at the beginning of the input. We then create our child process where we utilize the redirect symbols and check to see where we need to direct our input and output by closing and opening various files with differing flags depending on what symbol was used.

Additionally, we implemented signals to create a shell capable of handling background and foreground processes. First we ignore all the signals so our shell will not listen to the signals that we want the processes to listen to. Next, inside the REPL we decided it was necessary to reap all of the background processes and jobs to ensure that nothing is being left in a zombie state from a previous call. To do this we included a reaper helper method that would loop through all of the child processes and update status depending on if they had changed state. From there, we would check to see what changed our processes status, and then print out why it changed and then delete it from the jobs list. Furthermore in the method check_sys_cmnds we added the “jobs”, “fg”, and “bg” commands that could be understood by our shell. If there were no system commands to be handled by check_sys_cmnds in our input, we would then enter into a child process. There, if it is not a background process we make sure that the control of the shell is given to the child process, and the signals are reset to their defaults. If it's a background process, we then make sure the parent keeps control of the terminal, reset the signals to the default, and then print out the job number and pid. We then call execv to handle the input. After execv has been called, we then check again if the process is a foreground process and then we wait on it to finish unless a signal is utilized which we then handle by removing a job if it was terminated or add the job if it was stopped. If it was a background job we then add the job to the job list and increment the job number. After we give control back to the parent process. We also call cleanup job list after each time we exit. Overall, this shell should function with a myriad of commands and acted as an extremely helpful learning experience for me to better understand the inner workings of a terminal.
