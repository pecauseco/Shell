How to use: To use this shell, 1st
For Shell 2 we implemented signals to our original shell 1 and created a shell capable of handling background and foreground processes. First we ignore all the signals so our shell will not listen to the signals that we want the processes to listen to. Next, inside the REPL we decided it was necessary to reap all of the background processes and jobs to ensure that nothing is being left in a zombie state from a previous call. To do this we included a reaper helper method that would loop through all of the child processes and update status depending on if they had changed state. From there, we would check to see what changed our processes status, and then print out why it changed and then delete it from the jobs list. Everything else is the same as our shell 1 until we reach the check_sys_cmnds. In this method, we added the jobs, fg, and bg commands that could be understood by our shell. If there were no system commands in our input, then we would then enter into the child process. There, if it is not a background process we make sure that the control of the shell is given to the child process, and the signals are reset to their defaults. If its a background process, we then make sure the parent keeps control of the terminal, reset the signals to the default, and then print out the job number and pid. We then call execv to handle the input. After execv has been called, we then check again if the process is a foreground process and then we wait on it to finish unless a signal is utilized which we then handle by removing a job if it was terminated or add the job if it was stopped. If it was a background job we then add the job to the job list and increment the job number. After we give control back to the parent process. We also call cleanup job list after each time we exit.

